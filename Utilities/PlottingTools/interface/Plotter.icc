#include "TCanvas.h"
#include "TLegend.h"
#include "TH1F.h"
#include "TH2F.h"

#include "Utilities/PlottingTools/interface/PlottingTools.h"

#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

template <class NormPolicy>
Plotter<NormPolicy>::Plotter<NormPolicy>(): verbose_(false),rebin_(1){
   // Default colors/styles
   int colors[] = {kRed,kBlue,kMagenta};
   std::vector<int> vec_colors(colors,colors + sizeof(colors)/sizeof(int));
   int linestyles[] = {kDashed,kDotted,kDashDotted};
   std::vector<int> vec_linestyles(linestyles,linestyles + sizeof(linestyles)/sizeof(int));
   int fillstyles[] = {3004,3006,3005,3007,3013};
   std::vector<int> vec_fillstyles(fillstyles,fillstyles + sizeof(fillstyles)/sizeof(int)); 

   SetColors(vec_colors);
   SetLineStyles(vec_linestyles);
   SetFillStyles(vec_fillstyles);
}

//======================================================

template <class NormPolicy>
//void Plotter<NormPolicy>::plotComponents(VarMap const& variablesMap, const char* drawOption){
void Plotter<NormPolicy>::plotStack(VarMap const& variablesMap, const char* drawOption, bool firstAsRefHist){ 
   std::string option = std::string(drawOption);
 
   std::map<std::string,TCanvas*> canvasMap;
   std::map<std::string,TLegend*> legendMap;
   std::map<std::string,std::vector<HistDesc> > histoSets = loadHistos(variablesMap);
   std::map<std::string,std::vector<HistDesc> >::const_iterator set = histoSets.begin();
   std::map<std::string,std::vector<HistDesc> >::const_iterator sets_end = histoSets.end();
   for(; set != sets_end; ++set){
      const std::string& setName = set->first;
      canvasMap[setName] = new TCanvas(setName.c_str(),setName.c_str());
      canvasMap[setName]->cd();

      legendMap[setName] = new TLegend(0.4,0.7,0.95,0.8);
    
      std::vector<HistDesc> const& histos = set->second;
      std::vector<HistDesc> stackedHistos;
      if(firstAsRefHist){
         stackedHistos.resize(histos.size() - 1);
         std::copy(histos.begin() + 1, histos.end(), stackedHistos.begin());
      } else{
         stackedHistos.resize(histos.size()); 
         std::copy(histos.begin(), histos.end(), stackedHistos.begin());
      }
      THStack* stack = buildTHStack(setName,stackedHistos);
      stack->Draw(option.c_str());

      if(firstAsRefHist){
         HistDesc const& histoFirst = histos[0];
         histoFirst.first->SetMarkerSize(0.9);
         histoFirst.first->Draw("SAME");
      }     

      std::vector<HistDesc>::const_iterator histo = histos.begin();
      std::vector<HistDesc>::const_iterator histos_end = histos.end();
      for(; histo != histos_end; ++histo) legendMap[setName]->AddEntry(histo->first,histo->second.c_str(),"LPF");

      legendMap[setName]->SetFillColor(0);
      legendMap[setName]->Draw("SAME");
   }
}

template <class NormPolicy>
THStack* Plotter<NormPolicy>::buildTHStack(std::string const& name, std::vector<HistDesc> const& histos){

   std::vector<HistDesc> reversedHistos(histos);
   std::reverse(reversedHistos.begin(),reversedHistos.end());

   // Get reversed colors/styles as well
   std::vector<int> colors(histColors_);
   std::reverse(colors.begin(),colors.end());
   std::vector<int> linestyles(histLineStyles_);
   std::reverse(linestyles.begin(),linestyles.end());
   std::vector<int> fillstyles(histFillStyles_);
   std::reverse(fillstyles.begin(),fillstyles.end());
 
   THStack* stack = new THStack(("stack_" + name).c_str(),name.c_str());
   size_t index = 0;
   std::vector<HistDesc>::const_iterator it_histo = reversedHistos.begin();
   std::vector<HistDesc>::const_iterator histos_end = reversedHistos.end();
   //std::vector<HistDesc>::const_iterator histos_last = reversedHistos.end() - 1;
   for(; it_histo != histos_end; ++it_histo, ++index){
      TH1F* histo = it_histo->first;
      histo->SetLineColor(colors[index % colors.size()]);
      histo->SetLineStyle(linestyles[index % linestyles.size()]);
      histo->SetFillColor(colors[index % colors.size()]);
      histo->SetFillStyle(fillstyles[index % fillstyles.size()]);
      /*if(it_histo == histos_last){
         histo->SetLineStyle(1);
      } else{
         histo->SetLineStyle(vec_styles[index % vec_styles.size()]);
      }*/

      stack->Add(histo);
   }

   return stack;
}

template <class NormPolicy>
typename Plotter<NormPolicy>::HistMap Plotter<NormPolicy>::loadHistos(VarMap const& variablesMap){

   // HistDesc --> std::pair<TH1F*,std::string>
   std::map<std::string,std::vector<HistDesc> > histos;
   for(VarMap::const_iterator cat = variablesMap.begin(); cat != variablesMap.end(); ++cat){
      const std::string& catName = cat->first;

      histos[catName] = std::vector<HistDesc>();

      std::vector<VarDesc> const& vars = cat->second;
      size_t index = 0;
      for(std::vector<VarDesc>::const_iterator var = vars.begin(); var != vars.end(); ++var,++index){
         TH1F* histo_new = loadHisto(*var);
         std::string const& desc = var->label();
   
         histos[catName].push_back(std::make_pair(histo_new,desc));
      }
   }

   return histos;
}

template <class NormPolicy>
TH1F* Plotter<NormPolicy>::loadHisto(VarDesc const& var){
   std::string const& name = var.name();
   TDirectory const* dir = var.dir();
   //std::string const& desc = var.label();
   double normFactor = var.norm();

   if(verbose_) std::cout << " Accessing " << name << " in " << dir->GetName() << std::endl;

   TH1F* histo = getHisto(dir,name);
   // Clone histogram
   TH1F* histo_new = static_cast<TH1F*>(histo->Clone((name + "_scaled").c_str()));

   double scaleFactor = (histo_new->GetSumOfWeights() > 0.) ? NormPolicy::GetNorm(histo_new)*normFactor/histo_new->GetSumOfWeights() : 1.;
   scaleHisto(histo_new,scaleFactor,1,1,rebin_);

   return histo_new;
}


template <class NormPolicy>
typename Plotter<NormPolicy>::VarMap Plotter<NormPolicy>::makeVarMap(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors){

   if(normFactors.size() != directories.size()){
      std::string errMessage = "ERROR: Input vectors must have the same size."; 
      std::cout << errMessage << std::endl; 
      throw RootException(errMessage);
   }

   VarMap variablesMap;
   for(std::vector<std::string>::const_iterator var = variables.begin(); var != variables.end(); ++var){
      std::vector<VarDesc> varVector;
      size_t idx = 0;
      for(std::vector<std::pair<std::string,TDirectory*> >::const_iterator dir = directories.begin(); dir != directories.end(); ++dir,++idx){
         varVector.push_back(VarDesc(*var,dir->second,dir->first,normFactors[idx]));

      }
      variablesMap[*var] = varVector;
   }
   return variablesMap;
}

template <class NormPolicy>
void Plotter<NormPolicy>::plotStack(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap = makeVarMap(variables,directories,normFactors);
   plotStack(variablesMap,drawOption,false);
}

template <class NormPolicy>
void Plotter<NormPolicy>::plotComponents(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap = makeVarMap(variables,directories,normFactors);
   plotStack(variablesMap,drawOption,true);
}

//======================================================

template <class NormPolicy>
void Plotter<NormPolicy>::plot(VarMap& variablesMap,const char* drawOption){

   //std::string option = std::string(drawOption) + "SAME";
   std::string option = std::string(drawOption);

   std::map<std::string,TCanvas*> canvasesVar;
   std::map<std::string,TLegend*> legendsVar;
   std::map<std::string,std::vector<TH1F*> > histosVar;
   for(VarMap::iterator cat = variablesMap.begin(); cat != variablesMap.end(); ++cat){
      const std::string& catName = cat->first;
      canvasesVar[catName] = new TCanvas(catName.c_str(),catName.c_str());
      canvasesVar[catName]->cd();

      legendsVar[catName] = new TLegend(0.4,0.7,0.95,0.8);
    
      histosVar[catName] = std::vector<TH1F*>();

      std::vector<VarDesc>& vars = cat->second;
      //double maxVal = 0.;
      size_t index = 0;
      for(std::vector<VarDesc>::iterator var = vars.begin(); var != vars.end(); ++var,++index){

         /*const std::string& name = var->first;
         const std::string& desc = var->second.first;
         TDirectory* dir = var->second.second;*/
         /*const std::string& name = var->first;
         TDirectory* dir = var->second.first;
         const std::string& desc = var->second.second.first;
         double normFactor = var->second.second.second;*/
         const std::string& name = var->name();
         TDirectory* dir = var->dir();
         const std::string& desc = var->label();
         double normFactor = var->norm(); 
 
         if(verbose_) std::cout << " Accessing " << name << " in " << dir->GetName() << std::endl;
  
         TH1F* histo = getHisto(dir,name);

         //scaleHisto(histo,1,1,(index + 1));
         //scaleHisto(histo,1,1,(index + 1),rebin_); 
         //scaleHisto(histo,1,1,histColors_[index % histColors_.size()],rebin_);
         scaleHisto(histo,1.,histLineStyles_[index % histLineStyles_.size()],histColors_[index % histColors_.size()],rebin_);

         legendsVar[catName]->AddEntry(histo,desc.c_str(),"L"); 
         if(var == vars.begin()) histo->DrawNormalized(option.c_str(),NormPolicy::GetNorm(histo)*normFactor);
         else histo->DrawNormalized((option + "SAME").c_str(),NormPolicy::GetNorm(histo)*normFactor);
         //histo->DrawNormalized(option.c_str(),NormPolicy::GetNorm(histo));

         /*if(var == vars.begin()) maxVal = histo->GetMaximum();
         else {
            if(histo->GetMaximum() > maxVal) maxVal = histo->GetMaximum();
         }*/  
         histosVar[catName].push_back(histo);
      }
      legendsVar[catName]->SetFillColor(0);
      legendsVar[catName]->Draw(option.c_str());
      //histosVar[catName].back()->GetYaxis()->SetRangeUser(0.00000001,1.5*maxVal);
   }
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap;
   for(std::vector<std::string>::const_iterator var = variables.begin(); var != variables.end(); ++var){
      std::vector<VarDesc> varVector;
      size_t idx = 0;
      for(std::vector<std::pair<std::string,TDirectory*> >::const_iterator dir = directories.begin(); dir != directories.end(); ++dir,++idx){
         //varVector.push_back(std::make_pair(*var,*dir));
         //varVector.push_back(std::make_pair(*var,std::make_pair(dir->second,std::make_pair(dir->first,normFactors[idx]))));
         varVector.push_back(VarDesc(*var,dir->second,dir->first,normFactors[idx]));
         
      }
      variablesMap[*var] = varVector;
   }   
   plot(variablesMap,drawOption);  
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const char* drawOption){
   plot(variables,directories,std::vector<double>(directories.size(),1.0),drawOption);
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::map<std::string,std::vector<std::string> >& variables, TDirectory* dir, const char* drawOption){
   VarMap variablesMap;
   for(std::map<std::string,std::vector<std::string> >::const_iterator var = variables.begin();
                                                                       var != variables.end(); ++var){

      std::vector<VarDesc> varVector;
      for(std::vector<std::string>::const_iterator var_name = var->second.begin(); var_name != var->second.end(); ++var_name){
         //varVector.push_back(std::make_pair(*var_name,std::make_pair(*var_name,dir)));
         //varVector.push_back(std::make_pair(*var_name,std::make_pair(dir,std::make_pair(*var_name,1.0)))); 
         varVector.push_back(VarDesc(*var_name,dir,*var_name,1.0));
      }
      variablesMap[var->first] = varVector;
   }
   plot(variablesMap,drawOption);
}
