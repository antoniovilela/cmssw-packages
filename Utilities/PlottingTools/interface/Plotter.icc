#include "TCanvas.h"
#include "TLegend.h"
#include "TH1F.h"
#include "TH2F.h"

#include "Utilities/PlottingTools/interface/PlottingTools.h"

#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <sstream>

template <class NormPolicy>
Plotter<NormPolicy>::Plotter(): verbose_(false),rebin_(1),histStats_(true){
   // Default colors/styles
   int colors[] = {kRed,kBlue,kMagenta};
   std::vector<int> vec_colors(colors,colors + sizeof(colors)/sizeof(int));
   int linestyles[] = {kDashed,kDotted,kDashDotted};
   std::vector<int> vec_linestyles(linestyles,linestyles + sizeof(linestyles)/sizeof(int));
   int fillstyles[] = {3004,3006,3005,3007,3013};
   std::vector<int> vec_fillstyles(fillstyles,fillstyles + sizeof(fillstyles)/sizeof(int)); 
   int markerstyles[] = {1};
   std::vector<int> vec_markerstyles(markerstyles,markerstyles + sizeof(markerstyles)/sizeof(int));
   int markersizes[] = {1.};
   std::vector<float> vec_markersizes(markersizes,markersizes + sizeof(markersizes)/sizeof(float)); 

   SetLineColors(vec_colors);
   SetLineStyles(vec_linestyles);
   SetFillColors(vec_colors);
   SetFillStyles(vec_fillstyles);
   SetMarkerColors(vec_colors);
   SetMarkerStyles(vec_markerstyles); 
   SetMarkerSizes(vec_markersizes);
}

//======================================================

template <class NormPolicy>
void Plotter<NormPolicy>::plotStack(VarMap const& variablesMap, const char* drawOption, bool firstAsRefHist){ 
   Bool_t addStatus = TH1::AddDirectoryStatus();
   TH1::AddDirectory(kFALSE);

   std::string option = std::string(drawOption);
 
   std::map<std::string,TCanvas*> canvasMap;
   std::map<std::string,TLegend*> legendMap;
   HistMap histoSets = loadHistos(variablesMap);
   HistMap::const_iterator set = histoSets.begin();
   HistMap::const_iterator sets_end = histoSets.end();
   for(; set != sets_end; ++set){
      const std::string& setName = set->first;
      canvasMap[setName] = new TCanvas(setName.c_str(),setName.c_str());
      canvasMap[setName]->cd();

      legendMap[setName] = new TLegend(0.4,0.7,0.95,0.8);
    
      std::vector<HistDesc> const& histos = set->second;
      std::vector<HistDesc> stackedHistos;
      if(firstAsRefHist){
         stackedHistos.resize(histos.size() - 1);
         std::copy(histos.begin() + 1, histos.end(), stackedHistos.begin());
      } else{
         stackedHistos.resize(histos.size()); 
         std::copy(histos.begin(), histos.end(), stackedHistos.begin());
      }
      THStack* stack = buildTHStack(setName,stackedHistos);
      //stack->Draw(option.c_str());

      if(firstAsRefHist){
         HistDesc const& histoFirst = histos[0];
         histoFirst.first->SetMarkerStyle(20);
         histoFirst.first->SetMarkerSize(1.2);
         histoFirst.first->SetStats(0);
         stack->Draw(option.c_str());
         histoFirst.first->Draw("SAME][");
         //histoFirst.first->Draw(); 
         //stack->Draw( ( option + "SAME" ).c_str() );
      } else {
         stack->Draw(option.c_str());
      }  

      std::vector<HistDesc>::const_iterator histo = histos.begin();
      std::vector<HistDesc>::const_iterator histos_end = histos.end();
      for(; histo != histos_end; ++histo) legendMap[setName]->AddEntry(histo->first,histo->second.c_str(),"LPF");

      legendMap[setName]->SetFillColor(0);
      legendMap[setName]->Draw("SAME");
   }

   TH1::AddDirectory(addStatus);
}

template <class NormPolicy>
THStack* Plotter<NormPolicy>::buildTHStack(std::string const& name, std::vector<HistDesc> const& histos){

   std::vector<HistDesc> reversedHistos(histos);
   std::reverse(reversedHistos.begin(),reversedHistos.end());

   // Get reversed colors/styles as well
   std::vector<int> linecolors(histLineColors_);
   std::reverse(linecolors.begin(),linecolors.end());
   std::vector<int> linestyles(histLineStyles_);
   std::reverse(linestyles.begin(),linestyles.end());
   std::vector<int> fillcolors(histFillColors_);
   std::reverse(fillcolors.begin(),fillcolors.end());
   std::vector<int> fillstyles(histFillStyles_);
   std::reverse(fillstyles.begin(),fillstyles.end());
   std::vector<int> markercolors(histMarkerColors_);
   std::reverse(markercolors.begin(),markercolors.end());
   std::vector<int> markerstyles(histMarkerStyles_);
   std::reverse(markerstyles.begin(),markerstyles.end());
   std::vector<float> markersizes(histMarkerSizes_);
   std::reverse(markersizes.begin(),markersizes.end()); 

   THStack* stack = new THStack(("stack_" + name).c_str(),name.c_str());
   if(verbose_) std::cout << " Created THStack " << stack->GetName() << std::endl;
   size_t index = 0;
   std::vector<HistDesc>::const_iterator it_histo = reversedHistos.begin();
   std::vector<HistDesc>::const_iterator histos_end = reversedHistos.end();
   //std::vector<HistDesc>::const_iterator histos_last = reversedHistos.end() - 1;
   for(; it_histo != histos_end; ++it_histo, ++index){
      TH1F* histo = it_histo->first;
      histo->SetStats(histStats_);
      histo->SetLineColor(linecolors[index % linecolors.size()]);
      histo->SetLineStyle(linestyles[index % linestyles.size()]);
      histo->SetFillColor(fillcolors[index % fillcolors.size()]);
      histo->SetFillStyle(fillstyles[index % fillstyles.size()]);
      histo->SetMarkerColor(markercolors[index % markercolors.size()]);
      histo->SetMarkerStyle(markerstyles[index % markerstyles.size()]);
      histo->SetMarkerSize(markersizes[index % markersizes.size()]);
      /*if(it_histo == histos_last){
         histo->SetLineStyle(1);
      } else{
         histo->SetLineStyle(vec_styles[index % vec_styles.size()]);
      }*/

      stack->Add(histo);
   }

   return stack;
}

template <class NormPolicy>
typename Plotter<NormPolicy>::HistMap Plotter<NormPolicy>::loadHistos(VarMap const& variablesMap){

   // HistDesc --> std::pair<TH1F*,std::string>
   std::map<std::string,std::vector<HistDesc> > histos;
   for(VarMap::const_iterator cat = variablesMap.begin(); cat != variablesMap.end(); ++cat){
      const std::string& catName = cat->first;

      histos[catName] = std::vector<HistDesc>();

      std::vector<VarDesc> const& vars = cat->second;
      size_t index = 0;
      for(std::vector<VarDesc>::const_iterator var = vars.begin(); var != vars.end(); ++var,++index){
         TH1F* histo_new = loadHisto(*var,index);
         std::string const& desc = var->label();
   
         histos[catName].push_back(std::make_pair(histo_new,desc));
      }
   }

   return histos;
}

template <class NormPolicy>
TH1F* Plotter<NormPolicy>::loadHisto(VarDesc const& var, unsigned int index){
   std::string const& name = var.name();
   TDirectory const* dir = var.dir();
   //std::string const& desc = var.label();
   double normFactor = var.norm();

   if(verbose_) std::cout << " Accessing " << name << " in " << dir->GetName() << std::endl;

   TH1F* histo = getHisto(dir,name);
   // Clone histogram
   std::stringstream label;
   label << name << "_scaled_" << index; 
   TH1F* histo_new = static_cast<TH1F*>(histo->Clone(label.str().c_str()));

   double scaleFactor = (histo_new->GetSumOfWeights() > 0.) ? NormPolicy::GetNorm(histo_new)*normFactor/histo_new->GetSumOfWeights() : 1.;
   scaleHisto(histo_new,scaleFactor,1,1,rebin_);
   double binWidth = histo_new->GetBinWidth(1);
   char axisYTitle[50]; sprintf(axisYTitle,"/ (%f)",binWidth);
   histo_new->GetYaxis()->SetTitle(axisYTitle);

   return histo_new;
}


template <class NormPolicy>
typename Plotter<NormPolicy>::VarMap Plotter<NormPolicy>::makeVarMap(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors){

   if(normFactors.size() != directories.size()){
      std::string errMessage = "ERROR: Input vectors must have the same size."; 
      std::cout << errMessage << std::endl; 
      throw RootException(errMessage);
   }

   VarMap variablesMap;
   for(std::vector<std::string>::const_iterator var = variables.begin(); var != variables.end(); ++var){
      std::vector<VarDesc> varVector;
      size_t idx = 0;
      for(std::vector<std::pair<std::string,TDirectory*> >::const_iterator dir = directories.begin(); dir != directories.end(); ++dir,++idx){
         varVector.push_back(VarDesc(*var,dir->second,dir->first,normFactors[idx]));

      }
      variablesMap[*var] = varVector;
   }
   return variablesMap;
}

template <class NormPolicy>
void Plotter<NormPolicy>::plotHistos(std::vector<HistDesc> const& histos, std::string const& option){
   size_t index = 0;
   std::vector<HistDesc>::const_iterator it_histo = histos.begin();
   std::vector<HistDesc>::const_iterator histos_end = histos.end();
   for(; it_histo != histos_end; ++it_histo, ++index){
      TH1F* histo = it_histo->first;
      //std::string const& desc = it_histo->second;

      histo->SetStats(histStats_);
      histo->SetLineColor(histLineColors_[index % histLineColors_.size()]);
      histo->SetLineStyle(histLineStyles_[index % histLineStyles_.size()]);
      histo->SetFillColor(histFillColors_[index % histFillColors_.size()]);
      histo->SetFillStyle(histFillStyles_[index % histFillStyles_.size()]);
      histo->SetMarkerColor(histMarkerColors_[index % histMarkerColors_.size()]);
      histo->SetMarkerStyle(histMarkerStyles_[index % histMarkerStyles_.size()]);
      histo->SetMarkerSize(histMarkerSizes_[index % histMarkerSizes_.size()]);

      /*TH1F* histo_new = static_cast<TH1F*>(
               ( var == vars.begin() ) ?
               histo->DrawNormalized(option.c_str(),NormPolicy::GetNorm(histo)*normFactor) :
               histo->DrawNormalized((option + "SAME").c_str(),NormPolicy::GetNorm(histo)*normFactor) );*/

      if(it_histo == histos.begin()) histo->Draw(option.c_str());
      else histo->Draw((option + "SAME").c_str());
   }
}

template <class NormPolicy>
void Plotter<NormPolicy>::plotStack(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap = makeVarMap(variables,directories,normFactors);
   plotStack(variablesMap,drawOption,false);
}

template <class NormPolicy>
void Plotter<NormPolicy>::plotComponents(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap = makeVarMap(variables,directories,normFactors);
   plotStack(variablesMap,drawOption,true);
}

//======================================================

template <class NormPolicy>
void Plotter<NormPolicy>::plot(VarMap& variablesMap,const char* drawOption){

   Bool_t addStatus = TH1::AddDirectoryStatus();
   TH1::AddDirectory(kFALSE);

   std::string option = std::string(drawOption);

   std::map<std::string,TCanvas*> canvasMap;
   std::map<std::string,TLegend*> legendMap;
   HistMap histoSets = loadHistos(variablesMap);
   HistMap::const_iterator set = histoSets.begin();
   HistMap::const_iterator sets_end = histoSets.end();
   for(; set != sets_end; ++set){
      const std::string& setName = set->first;
      canvasMap[setName] = new TCanvas(setName.c_str(),setName.c_str());
      canvasMap[setName]->cd();

      legendMap[setName] = new TLegend(0.4,0.7,0.95,0.8);
    
      std::vector<HistDesc> const& histos = set->second;
      plotHistos(histos,option);

      std::vector<HistDesc>::const_iterator histo = histos.begin();
      std::vector<HistDesc>::const_iterator histos_end = histos.end();
      for(; histo != histos_end; ++histo) legendMap[setName]->AddEntry(histo->first,histo->second.c_str(),"LPF");

      legendMap[setName]->SetFillColor(0);
      legendMap[setName]->Draw("SAME");
   }

   TH1::AddDirectory(addStatus);
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const std::vector<double>& normFactors, const char* drawOption){
   VarMap variablesMap;
   for(std::vector<std::string>::const_iterator var = variables.begin(); var != variables.end(); ++var){
      std::vector<VarDesc> varVector;
      size_t idx = 0;
      for(std::vector<std::pair<std::string,TDirectory*> >::const_iterator dir = directories.begin(); dir != directories.end(); ++dir,++idx){
         //varVector.push_back(std::make_pair(*var,*dir));
         //varVector.push_back(std::make_pair(*var,std::make_pair(dir->second,std::make_pair(dir->first,normFactors[idx]))));
         varVector.push_back(VarDesc(*var,dir->second,dir->first,normFactors[idx]));
         
      }
      variablesMap[*var] = varVector;
   }   
   plot(variablesMap,drawOption);  
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::vector<std::string>& variables, std::vector<std::pair<std::string,TDirectory*> >& directories, const char* drawOption){
   plot(variables,directories,std::vector<double>(directories.size(),1.0),drawOption);
}

template <class NormPolicy>
void Plotter<NormPolicy>::plot(std::map<std::string,std::vector<std::string> >& variables, TDirectory* dir, const char* drawOption){
   VarMap variablesMap;
   for(std::map<std::string,std::vector<std::string> >::const_iterator var = variables.begin();
                                                                       var != variables.end(); ++var){

      std::vector<VarDesc> varVector;
      for(std::vector<std::string>::const_iterator var_name = var->second.begin(); var_name != var->second.end(); ++var_name){
         //varVector.push_back(std::make_pair(*var_name,std::make_pair(*var_name,dir)));
         //varVector.push_back(std::make_pair(*var_name,std::make_pair(dir,std::make_pair(*var_name,1.0)))); 
         varVector.push_back(VarDesc(*var_name,dir,*var_name,1.0));
      }
      variablesMap[var->first] = varVector;
   }
   plot(variablesMap,drawOption);
}
